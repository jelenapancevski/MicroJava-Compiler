package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

import java_cup.runtime.*;
import org.apache.log4j.*;

parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


nonterminal DeclarationList, Declaration, ConstDecl, ConstantList, VarDecl, VariablesList, ArrayBrackets, MethodDeclList, MethodDecl, MethodType, MethodParameterList, FormPars, MethodVariableList, MethodStatementList, Statement, PrintConstant, DesignatorStatement, DesignatorList, DesignatorListElement, Expr, AssignmentExpr, TermList, Term, FactorList, Factor, ActParams, ActPars, Condition, CondTerm, CondFact, Designator, Relop, Addop, Mulop;
terminal PROG, LBRACE, RBRACE, CONST, VOID, SEMICOLON, READ, PRINT, INCREMENT, DECREMENT, NEW, LPAREN, RPAREN, COMMA, DOT, LBRACKET, RBRACKET, EQUAL, ISEQUAL, NOTEQUAL, GT, GTE, LT, LTE, AND, OR, PLUS, MINUS, MULTIPLY, DIVIDE, MODUO;
/*terminal String IDENT;
terminal Integer NUMCONST; */

terminal IF, ELSE, WHILE, BREAK, CONTINUE, RETURN, FOREACH, ARROW;
nonterminal StatementsList;
terminal CLASS, THIS, COLON, DO, EXTENDS, ENUM;

terminal String IDENT;
terminal Character CHARCONST;
terminal Integer NUMCONST;
terminal Boolean BOOLCONST;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramIdentificator, ConstantDeclaration, Variable;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Constant;
 

precedence left ELSE;


Program ::= (Program) PROG ProgramIdentificator:programIdent DeclarationList LBRACE MethodDeclList RBRACE ;

ProgramIdentificator ::= (ProgramIdentificator) IDENT:progIdent ;

DeclarationList ::= (Declarations) DeclarationList Declaration 
				|
				(NoDeclarations) /*epsilon*/
				;

Declaration ::= (CnstDeclaration) ConstDecl 
				|
				(VariableDeclaration) VarDecl 
				/*|
				(ClassDeclaration) ClassDecl*/ 
				;
				
ConstDecl ::= (ConstDecl) CONST Type ConstantList SEMICOLON ;


ConstantList ::= (Constants) ConstantList COMMA ConstantDeclaration 
				|
				(OneConstant) ConstantDeclaration
				;
				
ConstantDeclaration ::= (ConstantDeclaration) IDENT:constName EQUAL Constant ;
				
Constant ::= (NumberConstant) NUMCONST:numConstant 
			|
			(CharConstant) CHARCONST:charConstant  
			|
			(BoolConstant) BOOLCONST:boolConstant 
			;
				
VarDecl ::= (VarDeclaration) Type VariablesList SEMICOLON
			|
			(ErrorVariableSemiColon)error SEMICOLON
			|
			(ErrorVariableComma)error COMMA VariablesList SEMICOLON 
			;

VariablesList ::= (Variables) VariablesList COMMA Variable 
				|
				(OneVariable) Variable 
				;	 

Variable ::= (Variable) IDENT:varName ArrayBrackets:isArray ;					
						
ArrayBrackets ::= (HasArrayBrackets) LBRACKET RBRACKET
					|
				  (NoArrayBrackets) /*epsilon*/
				  ; 

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl 
				|
				(NoMethods) /*epsilon*/
				;

MethodDecl ::= (MethodDecl) MethodType IDENT LPAREN MethodParameterList RPAREN MethodVariableList LBRACE MethodStatementList RBRACE;

MethodType ::= (ReturnMethodType) Type | (TypeVoid) VOID ;

MethodParameterList ::= (MethodParameters) FormPars 
					|
					(NoMethodParameters) /* epsilon */
					/*|
					(FormalParametersListError) error*/
					;
					
FormPars ::= (FormalParameters) FormPars COMMA Type IDENT ArrayBrackets
			|
			(OneFormalParameter) Type IDENT ArrayBrackets
			/*|
			(FormalParameterError) error */
			;

/*Parameter ::= (OneParameter)Type IDENT ArrayBrackets
				|
			  (OneParameterError ) error 
			;*/
			
MethodVariableList ::= (MethodVariables) MethodVariableList VarDecl
					|
					(NoMethodVariables) /* epsilon */
					;

MethodStatementList ::= (MethodStatements) MethodStatementList Statement
					|
					(NoMethodStatements) /* epsilon */
					;

Statement ::= (DesignatorStmt) DesignatorStatement SEMICOLON
				|
			 	(ReadStatement) READ LPAREN Designator RPAREN SEMICOLON
			 	|
			 	(PrintStatement) PRINT LPAREN Expr PrintConstant RPAREN SEMICOLON
			 	|
			 	(IfElseStatement) IF LPAREN Condition RPAREN Statement ELSE Statement
			 	|
			 	(IfStatement) IF LPAREN Condition RPAREN Statement
			 	|
			 	(WhileStatement) WHILE LPAREN Condition RPAREN Statement
			 	|
			 	(BreakStatement) BREAK SEMICOLON
			 	|
			 	(ContinueStatement) CONTINUE SEMICOLON
			 	|
			 	(ReturnStatement) RETURN SEMICOLON
			 	|
			 	(ReturnExpression) RETURN Expr SEMICOLON
			 	|
			 	(ForEachStatement) Designator DOT FOREACH LPAREN IDENT ARROW Statement RPAREN SEMICOLON
			 	|
			 	(MultipleStatements) LBRACE StatementsList RBRACE
			 	;
			 	
StatementsList ::= (Statements) StatementsList Statement
				|
				(NoStatement) /*epsilon */
			 	;
			 	
PrintConstant ::= (HasPrintConstant) COMMA NUMCONST
					|
				  (NoPrintConstant) /*epsilon*/
				  ;	

DesignatorStatement ::= (ValueIncrement) Designator INCREMENT 
						|
						(ValueDecrement) Designator DECREMENT
						|
						(Assignment) Designator EQUAL AssignmentExpr
						|
						(FuncionCall) Designator LPAREN ActParams RPAREN
						|
						(MultipleAssignment) LBRACKET DesignatorList RBRACKET EQUAL Designator
						|
						(MultipleAssignmentError) LBRACKET DesignatorList RBRACKET EQUAL error 
						;
						
AssignmentExpr ::= (AssignmentExpression) Expr
					|
					(AssignmentExprError) error
					;
					
DesignatorList ::= (Designators) DesignatorList COMMA DesignatorListElement 
				   |
				   (OneDesignatorListElement) DesignatorListElement
				   ;	
				   			
DesignatorListElement ::= (OneDesignatorElement)Designator 
						  |
						  (NoDesignatorElement)/*epsilon*/
						  ;
						
Expr ::= (NegativeExpression) MINUS TermList | (Expression) TermList ;

TermList ::= (Terms) TermList Addop Term | (OneTerm) Term ; 

Term ::= (Term) FactorList ;

FactorList ::= (Factors) FactorList Mulop Factor | (OneFactor) Factor ;

Factor ::= (FactorNumber) NUMCONST 
			|
			(FactorCharacter) CHARCONST 
			|
			(FactorBoolean) BOOLCONST
			|
			(BracketExpression) LPAREN Expr RPAREN
			|
			(ArrayCreation) NEW Type LBRACKET Expr RBRACKET
			|
			(ObjectCreation) NEW Type LPAREN ActParams RPAREN
			|
			(FunctionCall) Designator LPAREN ActParams RPAREN
			|
			(FactorDesignator) Designator
			;
			
ActParams ::= (ActualParams) ActPars 
				|
				(NoActualParams) /* epsilon */
				;

ActPars ::= (ActParsList) ActPars COMMA Expr 
			|
			(OneActParameter) Expr
			;	
			
Condition ::= (Conditions) Condition OR CondTerm 
			  |
			  (OneCondition) CondTerm 
			  ;

CondTerm ::= (ConditionTerms) CondTerm AND CondFact 
			|
			(ConditionTerm) CondFact
			;

CondFact ::= (ConditionFacts) Expr Relop Expr 
			|
			(ConditionFact) Expr
			;			

/* 
Designator := ident [ "[" Expr "]" ]. 
*/
						
Designator ::= (OneDesignator) IDENT 
				| 
				(ArrayDesignator) IDENT LBRACKET Expr RBRACKET 
				;

Relop ::= (IsEqual) ISEQUAL | (NotEqual) NOTEQUAL | (Greater) GT | (GreaterEqual) GTE | (LessThan) LT | (LessThanEqual) LTE ;

Addop ::= (Plus) PLUS | (Minus) MINUS ;

Mulop ::= (Multiply) MULTIPLY | (Divide) DIVIDE | (Moduo) MODUO ;

Type ::= (Type) IDENT:typeName ;